# Sliding Window Pattern

Useful when we have a set of data like an array or string and we're looking for a **continuous subset** of that data.

This pattern involves creating a **window** (a range of elements) that slides from one position to another, maintaining a fixed size or expanding/contracting based on conditions.

## When to Use:
- Finding maximum/minimum sum of k consecutive elements
- Longest substring with certain conditions
- Finding patterns in continuous data

## Key Concept:
Instead of recalculating everything from scratch, we **slide** the window by:
- Adding new elements entering the window
- Removing elements leaving the window

**Example:** Finding max sum of 3 consecutive numbers
```
Array: [2, 1, 5, 1, 3, 2]
Window slides: [2,1,5] → [1,5,1] → [5,1,3] → [1,3,2]
```

## Example

Write a function called maxSubarraySum which accepts an array of integers and a number called **n**. The function should calculate the maximum sum of **n** consecutive elements in the array.

```javascript
maxSubarraySum([1,2,5,2,8,1,5], 2) // 10
maxSubarraySum([1,2,5,2,8,1,5], 4) // 17
maxSubarraySum([4,2,1,6], 1) // 6
maxSubarraySum([4,2,1,6,2], 4) // 13
maxSubarraySum([], 4) // null
```

### Naive Solution

```javascript
function maxSubarraySum(arr, num) {
    if (num > arr.length) {
        return null;
    }
    var max = -Infinity;
    for (let i = 0; i < arr.length - num + 1; i++) {
        let temp = 0;
        for (let j = 0; j < num; j++) {
            temp += arr[i + j];
        }
        if (temp > max) {
            max = temp;
        }
    }
    return max;
}
```

### Sliding Window Pattern - O(N)

```javascript
function maxSubarraySum(arr, num) {
    let tempSum = 0;
    let maxSum = 0;
    for (let i = 0; i < num; i++) {
        maxSum += arr[i];
    }
    tempSum = maxSum;
    for (let i = num; i < arr.length; i++) {
        tempSum = tempSum - arr[i - num] + arr[i];
        maxSum = Math.max(maxSum, tempSum);
    }
    return maxSum;
}
```

**Step-by-step example:** `maxSubarraySum([2, 1, 5, 1, 3, 2], 3)`

**Step 1:** Calculate first window sum
```
Window: [2, 1, 5]
maxSum = 2 + 1 + 5 = 8
tempSum = 8
```

**Step 2:** Slide the window
```
i=3: Slide window right
Remove arr[0] = 2, Add arr[3] = 1
tempSum = 8 - 2 + 1 = 7
Window: [1, 5, 1] = 7
maxSum = max(8, 7) = 8

i=4: Slide window right  
Remove arr[1] = 1, Add arr[4] = 3
tempSum = 7 - 1 + 3 = 9
Window: [5, 1, 3] = 9
maxSum = max(8, 9) = 9

i=5: Slide window right
Remove arr[2] = 5, Add arr[5] = 2  
tempSum = 9 - 5 + 2 = 6
Window: [1, 3, 2] = 6
maxSum = max(9, 6) = 9
```

**Final result:** 9

**Key insight:**
- **Reuse calculations:** Instead of recalculating entire sum, just subtract the leaving element and add the entering element
- **O(n) time:** Only one pass through the array after initial window
- **Sliding formula:** `newSum = oldSum - leftElement + rightElement`

**Comparison:**
- **Naive approach:** O(n × k) - recalculate sum for each window
- **Sliding window:** O(n) - calculate once, then slide efficiently