# Frequency Counter Pattern

This pattern uses objects or sets to collect values or frequencies of values. This can often avoid the need for nested loops or O(N²) operations with arrays / strings.

## When to Use:
- Comparing two arrays or strings for similar composition
- Counting occurrences of characters, numbers, or patterns
- Finding anagrams or permutations
- Checking if arrays have same frequency of elements
- Avoiding nested loops when comparing data sets

## Key Concept:
Instead of nested loops (O(n²)), use objects to:
- **Count frequencies** in separate O(n) loops
- **Compare counts** rather than searching repeatedly
- **Trade space for time** - use more memory for better performance

**Pattern:** 
1. Loop through first dataset → build frequency object
2. Loop through second dataset → build frequency object  
3. Compare the frequency objects

**Benefit:** 3 separate O(n) loops = O(n) vs nested loops = O(n²)

## Example

1. Write a function called same, which accepts two arrays. The function should return true if every value in the array has it's corresponding value squared in the second array. The frequency of values must be the same.

```javascript
same([1,2,3], [4,1,9]) // true
same([1,2,3], [1,9]) // false
same([1,2,1], [4,4,1]) // false (must be same frequency) 
```

### Naive approach - O(N^2)

```javascript
function same(arr1, arr2) {
    if (arr1.length !== arr2.length) return false;
    for (let i = 0; i < arr1.length; i++) {
        let correctIndex = arr2.indexOf(arr1[i] ** 2);
        if (correctIndex ==== -1) {
            return false
        }

        arr2.splice(correctIndex, 1);
    }

    return true;
}
```

### Frequency Counter Pattern - O(n)

Instead of looping over the first array and then checking each value inside a nested loop over the second array, we can loop through each array individually. **Remember that two separate loops are far more efficient than a nested loop. For example, if each array has 1,000 items, two separate loops result in 2,000 iterations, while a nested loop would result in 1,000,000 iterations.**

```javascript
function same(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    let frequencyCounter1 = {}
    let frequencyCounter2 = {}
    for (let i = 0; i < arr1.length; i++) {
        if (!frequencyCounter1[arr1[i]]) frequencyCounter1[arr1[i]] = 0;
        frequencyCounter1[arr1[i]]++;
    }
    for (let i = 0; i < arr2.length; i++) {
        if (!frequencyCounter2[arr2[i]]) frequencyCounter2[arr2[i]] = 0;
        frequencyCounter2[arr2[i]]++;
    }
    for (let key in frequencyCounter1) {
        if (!(key ** 2 in frequencyCounter2)) {
            return false;
        }
        if (frequencyCounter1[key] !== frequencyCounter2[key ** 2]) {
            return false;
        }
    }
   return true;
}
```
### Frequency Counter Pattern - O(n)

Instead of looping over the first array and then checking each value inside a nested loop over the second array, we can loop through each array individually. **Remember that two separate loops are far more efficient than a nested loop. For example, if each array has 1,000 items, two separate loops result in 2,000 iterations, while a nested loop would result in 1,000,000 iterations.**

```javascript
function same(arr1, arr2) {
    // Step 1: Quick length check
    if (arr1.length !== arr2.length) {
        return false;
    }
    
    // Step 2: Create frequency counter objects
    let frequencyCounter1 = {}  // Count frequencies in arr1
    let frequencyCounter2 = {}  // Count frequencies in arr2
    
    // Step 3: Build frequency map for arr1
    for (let i = 0; i < arr1.length; i++) {
        if (!frequencyCounter1[arr1[i]]) frequencyCounter1[arr1[i]] = 0;
        frequencyCounter1[arr1[i]]++;
    }
    
    // Step 4: Build frequency map for arr2
    for (let i = 0; i < arr2.length; i++) {
        if (!frequencyCounter2[arr2[i]]) frequencyCounter2[arr2[i]] = 0;
        frequencyCounter2[arr2[i]]++;
    }
    
    // Step 5: Compare frequencies
    for (let key in frequencyCounter1) {
        // Check if squared value exists in arr2
        if (!(key ** 2 in frequencyCounter2)) {
            return false;
        }
        // Check if frequencies match
        if (frequencyCounter1[key] !== frequencyCounter2[key ** 2]) {
            return false;
        }
    }
    
    return true;
}
```

**How it works step-by-step:**

**Example:** `same([1,2,1], [4,1,4])`

**Step 1:** Length check ✅ (both arrays have 3 elements)

**Step 2-3:** Build frequency map for arr1 `[1,2,1]`
```
i=0: arr1[0] = 1 → frequencyCounter1 = {1: 1}
i=1: arr1[1] = 2 → frequencyCounter1 = {1: 1, 2: 1}  
i=2: arr1[2] = 1 → frequencyCounter1 = {1: 2, 2: 1}
```

**Step 4:** Build frequency map for arr2 `[4,1,4]`
```
i=0: arr2[0] = 4 → frequencyCounter2 = {4: 1}
i=1: arr2[1] = 1 → frequencyCounter2 = {4: 1, 1: 1}
i=2: arr2[2] = 4 → frequencyCounter2 = {4: 2, 1: 1}
```

**Step 5:** Compare frequencies
```
key = "1": 1² = 1 exists in arr2? ✅ | frequency match? 2 !== 1 ❌
Return false
```

**Key insight:** 
- **Frequency counting:** `if (!obj[key]) obj[key] = 0; obj[key]++`
- **Squared lookup:** `key ** 2 in frequencyCounter2` 
- **Frequency comparison:** Must have same count of original and squared values