# Divide and Conquer Pattern

This pattern involves dividing a data set into smaller chunks and then repeating a process with a subset of data. This pattern can tremendously **decrease time complexity**.

## When to Use:
- Searching in **sorted** arrays (binary search)
- Sorting algorithms (merge sort, quick sort)
- Finding maximum/minimum in large datasets
- Tree traversal and manipulation
- Mathematical computations (exponentiation, matrix multiplication)
- Problems that can be broken into similar subproblems

## Key Concept:
Instead of checking every element (O(n)), divide the problem:
- **Divide:** Split data into smaller pieces
- **Conquer:** Solve subproblems recursively
- **Combine:** Merge results if needed

**Classic example:** Binary Search
- **Linear search:** Check every element = O(n)
- **Binary search:** Eliminate half each time = O(log n)

**Pattern:**
1. **Base case:** Problem small enough to solve directly
2. **Divide:** Split into smaller subproblems
3. **Conquer:** Recursively solve subproblems
4. **Combine:** Merge solutions (if needed)

**Benefit:** Transforms O(n) problems into O(log n) solutions

## Example

Given a sorted array of integers, write a function called search, that accepts a value and returns the index where the value passed to the function is located. If value is not found, return -1.

```javascript
search([1,2,3,4,5,6],4) // 3 
search([1,2,3,4,5,6],6) // 5
search([1,2,3,4,5,6],11) // -1
```

### Naive Solution - O(N)

```javascript
function search(arr, val) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === val) {
            return i;
        }
    }
    return -1;
}
```

### Divide and Conquer Pattern - (Binary Search) 

Time Complexity - Log(N)

```javascript
function search(arr, val) {
    let min = 0;                    // Left boundary
    let max = arr.length - 1;      // Right boundary

    while (min <= max) {            // Continue while search space exists
        let middle = Math.floor((min + max) / 2);  // Find middle point
        let currentElement = arr[middle];

        if (arr[middle] < val) {
            min = middle + 1;       // Target in right half, eliminate left
        } else if (arr[middle] > val) {
            max = middle - 1;       // Target in left half, eliminate right
        } else {
            return middle;          // Found target!
        }
    }

    return -1;                      // Target not found
}
```
### Binary Search - Explained

**Step-by-step example:** `search([1, 2, 3, 4, 5, 6, 7, 8, 9], 6)`

```
Step 1: min=0, max=8
[1, 2, 3, 4, 5, 6, 7, 8, 9]
 ↑           ↑           ↑
min       middle        max
middle = floor((0+8)/2) = 4
arr[4] = 5 < 6 → target in right half
min = 4 + 1 = 5

Step 2: min=5, max=8  
[1, 2, 3, 4, 5, 6, 7, 8, 9]
                ↑     ↑     ↑
              min  middle  max
middle = floor((5+8)/2) = 6
arr[6] = 7 > 6 → target in left half
max = 6 - 1 = 5

Step 3: min=5, max=5
[1, 2, 3, 4, 5, 6, 7, 8, 9]
                ↑
            min/middle/max
middle = floor((5+5)/2) = 5
arr[5] = 6 = 6 → Found! Return 5
```

**Key insights:**
- **Eliminate half:** Each comparison removes ~50% of remaining elements
- **Boundary management:** `min` and `max` track the current search space
- **Middle calculation:** `Math.floor((min + max) / 2)` finds center point
- **Three outcomes:** Target found, search left half, or search right half

**Why it's O(log n):**
- Array of 1000 elements: ~10 comparisons maximum
- Array of 1,000,000 elements: ~20 comparisons maximum
- Each step cuts search space in half: n → n/2 → n/4 → n/8 → ... → 1